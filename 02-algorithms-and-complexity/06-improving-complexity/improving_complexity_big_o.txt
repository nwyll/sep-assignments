1. Improvement One - code optimizations
For the first improvements I went small (I had two more to go), just implementing some code optimizations that would improve the run time but not the overall complexity of the algorithm. Arrays.each (line 3) iterates over the arrays passed into the method, The more arrays passes in, the complexity increases linearly. Similarly, the concat method is simply splicing the new array into the original one so combined_array.concat(array) (also line 3) will need to iterate over each item in the individual array passed in. This will also take happen in O(n) time. The combined array is then sorted using an insertion sort, which takes O(n^2) time, because it has to iterate twice over the collection. In all we have O(n) iterating over the number of arrays passed in, then for each array passed in we have O(n) time that is dependent on the length of each individual array resulting in O(n^2). Plus another O(n^2) time for the sorting of the array. Overall we have O(n^2) + O(n^2) = O(2* n^2) or just O(n^2) for this algorithm.

2. Improvement Two - more efficient sorting algorithm
In this iteration I kept the code improvements from #1, but used merge sort instead of insertion sort. Merge sort on average has a Big-O of O(nlogn). So we still have O(n^2) to combine the arrays into one, plus O(nlogn) to sort the array. (In benchmarking this was not as fast as improvement #1, probably because insertion sort does work well for small arrays vs. merge sort recursive implementation.)

3. Improvement Three - code optimizations & more efficient sorting algorithm
In this iteration of the algorithm, I used Ruby's built in sort method, which uses quick sort. Quick sort has a Big-O of O(nlogn). This is the same complexity as the merge sort used in #2, but as you can see the length of the method is reduced from 24 lines of code to just 3 lines. This should improve the overall run time of this implementation because many constant time operations are removed. (My non-exhaustive benchmarking did show that this was the fastest of the 4 implementations.)

4. Improvement Four
If I was asked to write a method that takes in multiple arrays and combines them to one sorted array, this is probably what I would implement. But since my research did not lead me to finding the time complexity of Ruby's flatten method I did the other 3 implementations. I know flatten is recursive if terms of how many levels deep it goes to unpack arrays with in arrays, so this method might not be great (i.e. slow) if you had arrays with in arrays within arrays. But I love a one liner. My non-exhaustive benchmarking did show that this was the second fastest of the 4 implementations. As expected though, it was not as fast as improvement #3's iterative approach to combining the arrays due to flatten's recursive implementation.
